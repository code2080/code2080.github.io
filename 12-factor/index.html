<!DOCTYPE html>
<html>
<head>
    <title>Xây dựng ứng dụng theo 12 yếu tố (Twelve-Factor App) // Code Twenty Eighty</title>

        <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="description" content="">
    <meta name="keywords" content="">
    <meta name="author" content="">
        <meta property="og:title" content="Xây dựng ứng dụng theo 12 yếu tố (Twelve-Factor App)" />
    <meta property="og:description" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:url" content="https://code2080.com/12-factor/" />
    

    <link href="" rel="alternate" type="application/rss+xml" title="Code Twenty Eighty" />
    <link rel="shortcut icon" href="/favicon.png">

    <link href="https://code2080.com/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="https://code2080.com/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="https://code2080.com/css/style.css">

    <link href="http://gmpg.org/xfn/11" rel="profile">
    
    <meta name="generator" content="Hugo 0.48" />
</head>


<body>
<div id="container">
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="https://code2080.com/">Code Twenty Eighty</a>
            <nav id="main-nav">
                
            </nav>
            <nav id="sub-nav">
                <div id="search-form-wrap">
                </div>
            </nav>
        </div>
    </div>
</header>
    <section id="main" class="outer">
        <article class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        <header class="article-header">
            <h1 class="article-title" itemprop="name">Xây dựng ứng dụng theo 12 yếu tố (Twelve-Factor App)</h1>
        </header>
        
        <div class="article-meta">
            <a href="/12-factor/" class="article-date">
                <time datetime='2018-09-19T00:46:35.000&#43;07:00' itemprop="datePublished">2018-09-19</time>
            </a>
            
            
            
        </div>
        <div class="article-entry" itemprop="articleBody">
            

<p>Nguồn: <a href="https://12factor.net/">https://12factor.net/</a></p>

<h1 id="mở-đầu">MỞ ĐẦU</h1>

<h2 id="giới-thiệu">Giới thiệu</h2>

<p>Trong kỷ nguyên hiện đại, phần mềm thông thường được cung cấp như một dịch vụ: được gọi là <em>web apps</em> (những ứng dụng web), hay là <em>software-as-a-service</em> (phần mềm như một dịch vụ). App (ứng dụng) xây dựng theo twelve-factor là một phương pháp học để xây dựng app như vậy, bao gồm:</p>

<ul>
<li>Sử dụng định dạng <strong>declarative</strong> cho thiết lập tự động, để giảm thiểu tối đa thời gian và công sức cho những lập trình viên mới tham gia vào dự án;</li>
<li>Có <strong>giao kèo sạch</strong> (clean contract) với hệ thống vận hành ở bên dưới, đưa ra <strong>tối đa tính khả chuyển</strong> (maximum portability) giữa các môi trường thực thi;</li>
<li>Tiện dụng cho <strong>phát triển</strong> trên <strong>nền tảng điện toán đám mây</strong> hiện đại, loại bỏ sự cấp thiết cho các máy chủ và những người quản trị hệ thống;</li>
<li><strong>Giảm thiểu tối đa sự khác nhau</strong> giữa development (phát triển) và production (sản phẩm), kích hoạt tính năng <strong>phát triển liên tục</strong> (CD, continuous deployment) để tối đa tốc độ phát triển app;</li>
<li>Và có thể <strong>mở rộng</strong> mà không cần thay đổi đáng kể nào về công cụ, kiến trúc, hay các phương pháp phát triển (development practices).</li>
</ul>

<p>Phương pháp twelve-factor có thể áp dụng cho app viết bằng bất cứ ngôn ngữ nào, và sử dụng bất kì sự kết hợp nào của các dịch vụ ở backend (như cơ sở dữ liệu, queue, memory cache,&hellip;).</p>

<h2 id="khởi-nguồn">Khởi nguồn</h2>

<p>Những người đóng góp cho tài liệu này đều đã trực tiếp gặp phải những rắc rối trong sự phát triển một cũng như hàng trăm app, và gián tiếp chứng kiến sự phát triển, vận hành, và mở rộng của hàng trăm triệu app thông qua công việc của chúng tôi ở nền tảng Heroku.</p>

<p>Tài liệu này tổng hợp tất cả kinh nghiệm và sự quan sát của chúng tôi trong thế giới rộng lớn của software-as-a-service app. Nó là một tam phân của những thực hành ý tưởng trong phát triển app, đặc biệt chú ý đến sự dynamic (năng động) của việc phát triển cơ bản của một app qua thời gian, sự dynamic của cộng tác giữa các developer (nhà phát triển) làm việc trên cùng mã nguồn app, và <a href="http://blog.heroku.com/archives/2011/6/28/the_new_heroku_4_erosion_resistance_explicit_contracts/">tránh chi phí của việc sói mòn phần mềm</a>.</p>

<p>Động lực của chúng tôi là để nâng cao nhận thức về một số lỗi truyền thống mà chúng ta thấy trong phát triển app hiện đại, để cung cấp những ngôn từ chung để thảo luận về những vấn đề đó, và để đưa ra một tập rộng các giải pháp mang tính khái niệm cho những vấn đề đó với những thuật ngữ kèm theo. Định dạng này được lấy cảm hứng bởi cuốn sách <a href="https://books.google.com/books/about/Patterns_of_enterprise_application_archi.html?id=FyWZt5DdvFkC">Patterns of Enterprise Application Architecture and Refactoring</a> của Martin Fowler.</p>

<h2 id="ai-nên-đọc-tài-liệu-này">Ai nên đọc tài liệu này?</h2>

<p>Bất kỳ developer nào, mà xây dựng app chạy như là một dịch vụ. Kỹ sư hệ thống, người triển khai và quản lý các app như vậy.</p>

<h1 id="1-codebase-toàn-bộ-mã-nguồn-dự-án">1. Codebase (Toàn bộ mã nguồn dự án)</h1>

<p><strong>Một codebase thì được theo dõi trong kiểm soát sửa đổi, và có nhiều bản triển khai</strong></p>

<p>Một twelve-factor app thì luôn luôn được theo dõi trong một hệ thống quản lý phiên bản, ví dụ như Git, Mercurial, hoặc Subversion. Một bản sao chép của cơ sở dữ liệu theo dõi sửa đổi (revision tracking database) thì được biết như là một <em>code repository</em>, hay thường gọi tắt là <em>code repo</em> hoặc chỉ là <em>repo</em>.</p>

<p>Một <em>codebase</em> có thể là bất kì một repo đơn nào (trong một hệ thống kiểm soát sửa đổi tập trung như Subversion), hoặc bất kì một tập repo nào được chia sẻ root commit (trong một hệ thống kiểm soát sửa đổi phi tập trung như Git).</p>

<p>Luôn luôn có sự tương quan một-một giữa codebase và app:</p>

<p><em>Mỗi codebase có nhiều deploy:</em>
<img src="/images/codebase-deploys.png" alt="alt text" title="One codebase maps to many deploys" /></p>

<ul>
<li><p>Nếu có nhiều codebase, thì nó không phải một app, mà là một hệ thống phân tán. Mỗi thành phần trong một hệ thống phân tán là một app, và mỗi thành phần đó có thể tuân theo một cách cá nhân với twelve-factor.</p></li>

<li><p>Nhiều app chia sẻ mã giống nhau là một sự vi pham trong twelve-factor. Giải pháp ở đây là để những phần chia sẻ code chung vào thành những thư viện, mà có thể được bao hàm thông qua trình quản lý phụ thuộc (<a href="#2-dependencies-c%C3%A1c-ph%E1%BB%A5-thu%E1%BB%99c">dependency manager</a>).</p></li>
</ul>

<p>Chỉ có duy nhất một codebase với mỗi app, nhưng sẽ có nhiều deploy (triển khai) của một app. Một <em>deploy</em> là một instance (thực thể) của app, điển hình nó có thể là một production site, và là một hoặc nhiều staging sites. Thêm nữa, mọi developer đều có một bản sao chép của app chạy ở môi trường phát triển local của họ, mỗi trong số đó cũng đều được coi là một bản deploy.</p>

<p>Codebase thì giống nhau ở tất cả các deploy, mặc dù các phiên bản khác nhau có thể được active ở mỗi deploy. Ví dụ, một developer có một số commit chưa được deploy đến staging; staging thì cũng có một số commit chưa được deploy đến production. Nhưng chúng đều chia sẻ codebase giống nhau, ví vậy để chúng có thể nhận biết được như là các deploy khác nhau của cùng một app.</p>

<h1 id="2-dependencies-các-phụ-thuộc">2. Dependencies (Các phụ thuộc)</h1>

<p><em>Khai báo rõ ràng và cô lập các dependency (phụ thuộc)</em></p>

<p>Hầu hết các ngôn ngữ lập trình đều đưa ra hệ thống quản lý gói (packaging system) cho việc phân phối các thư viện hỗ trợ, ví dụ như CPAN cho Perl, Rubygems for Ruby, NPM cho NodeJS, Pip cho Python. Thư viện được cài đặt thông qua một hệ thống quản lý gói có thể được cài đặt trong phạm vi toàn hệ thống (system-wide) (được biết như là &ldquo;site packages&rdquo;) hoặc giới hạn phạm vi trong thư mục chứa app (được biết như là &ldquo;vendoring&rdquo; hay &ldquo;bundling&rdquo;).</p>

<p><strong>Một twelve-factor app không bao giờ tin vào sự tồn tại ngầm của các gói trên toàn hệ thống (system-wide packages)</strong>. Nó khai báo tất cả các dependency, trọn vẹn và chính xác, thông qua một bản kê <em>khai báo dependency (dependency declaration)</em>. Hơn nữa nó sử dụng một công cụ <em>cô lập dependency (dependency isolation)</em> trong quá trình thực thi, để chắc rằng không có dependency ngầm nào &ldquo;bị rò rỉ vào trong&rdquo; (&ldquo;leak in&rdquo;) từ hệ thống xung quanh. Bản đặc tả dependency đầy đủ và rõ ràng được áp dụng đồng nhất với cả production và development.</p>

<p>Ví dụ, Bundler (Trình đóng gói) cho Ruby đưa ra định dạng bản kê <code>Gemfile</code> cho khai báo dependency và <code>bundle exec</code> cho các cô lập dependency. Trong Python, có 2 công cụ riêng biệt cho các bước này - Pip sử dụng cho khai báo, Virtualenv cho cô lập. Thậm chí C có Autoconf cho khai báo dependency, và liên kết tĩnh (static linking) có thể cung cấp cô lập denpendency. Bất kể toolchain nào (tập công cụ lập trình), khai báo và cô lập dependency phải luôn luôn được sử dụng cùng nhau - chỉ cái này hoặc cái kia là không đủ thoả mãn twelve-factor.</p>

<p>Một lợi ích của khai báo dependency rõ ràng là nó làm đơn giản việc thiết lập cho những developer mới tham gia vào app. Developer mới có thể check out codebase của app sang máy phát triển của họ, chỉ yêu cầu có trình chạy của ngôn ngữ (language runtime) và trình quản lý dependency được cài đặt như điều kiện trước hết. Họ sẽ có thể thiết lập mọi thứ cần thiết để chạy mã nguồn app với <em>câu lệnh build</em> xác định. Ví dụ, câu lệnh build cho Ruby/Bundler là <code>bundle install</code>, còn cho Clojure/leiningen là <code>lein deps</code>.</p>

<p>Twelve-factor app cũng không dựa vào tồn tại ngầm của bất kỳ công cụ hệ thống nào. Ví dụ bao gồm shelling out đến ImageMagick hoặc <code>curl</code>. Trong khi những công cụ này có thể tổn tại trên nhiều hoặc thậm chí hầu hết hệ thống, tuy nhiên không có gì đảm bảo rằng chúng sẽ tồn tại trên tất cả hệ thống nơi mà app của bạn có thể chạy trong tương lai, hoặc liệu phiên bản được tìm thấy trên một hệ thống trong tương lai sẽ tương thích với app. Nếu app cần shell out đến một công cụ hệ thống, thì công cụ này nên được cung cấp trong app.</p>

<h1 id="3-config-cấu-hình">3. Config (Cấu hình)</h1>

<p><em>Lưu trữ cấu hình trong môi trường</em></p>

<p>Một cấu hình app là mọi thứ có khả năng thay đổi giữa các bản deploy (staging, production, developer environments, &hellip;). Bao gồm:</p>

<ul>
<li>Tài nguyên xử lý database, Memcached, và các dịch vụ đằng sau khác (backing services)</li>
<li>Uỷ nhiệm đến dịch vụ bên ngoài (external services) như Amazon S3 hay Twitter</li>
<li>Các giá trị trên mỗi deploy như hostname kiểu mẫu cho deploy</li>
</ul>

<p>Các app thỉnh thoảng lưu trữ cấu hình như hằng số trong code. Điều này vi phạm twelve-factor, nó yêu cầu sự <strong>phân chia chặt chẽ của cấu hình từ code</strong> (strict separation of config from code). Cấu hình về thực chất sẽ thay đổi qua các deploy, code (mã nguồn) không làm điều này.</p>

<p>Một bài kiểm thử (litmus test) là liệu một app có tất cả cấu hình đúng được đặt ngoài code không chính là liệu codebase có thể trở thành open source (mã nguồn mở) bất cứ lúc nào không, mà cần thoả hiệp bất cứ uỷ nhiệm (credential) nào.</p>

<p>Chú ý rằng định nghĩa này của &ldquo;config&rdquo; không bao gồm cho cấu hình ứng dụng bên trong (internal application config), ví dụ <code>config/routes.rb</code> trong Rails, hay cách mà những mô-đun code được kết nối trong Spring. Kiểu này của config không thay đổi giữa các deploy, vì vậy tốt nhất là để nó ở trong code.</p>

<p>Một cách tiếp cận khác để config là sử dụng các tệp cấu hình (config files) mà không được đánh dấu vào trong trình kiểm soát mã nguồn, ví dụ như <code>config/database.yml</code> trong Rails. Việc này là cải thiện rất lớn thay cho việc sử dụng hằng số mà được đánh dấu trong code repo, nhưng nó vẫn có những điểm yếu; là rất dễ mắc sai lầm đánh dấu một config file trong repo; có một xu hướng cho những file config bị phân tán ở các nơi khác nhau và định dạng khác nhau, làm cho việc xem và quản lý tất cả các config ở một nơi khó khăn. Hơn nữa, những định dạng này hướng theo đặc tả của ngôn ngữ hoặc framework.</p>

<p><strong>Twelve-factor app lưu config trong biến môi trường</strong> (<em>environment variables</em>, thường viết ngắn gọn là <em>env vars</em> hay <em>env</em>). Env vars dễ dàng thay đổi giữa các deploy mà không phải thay đổi code; không giống như file config, chúng chỉ có nguy cơ nhỏ không may bị đánh dấu trong code repo; và cũng không giống như file config tuỳ chỉnh, hay các cơ chế config khác ví dụ Java System Properties, chúng là theo chuẩn không thể biết của ngôn ngữ lập trình và OS (hệ điều hành) (language- and OS-agnostic standard).</p>

<p>Một mặt khác của quản lý config là đặt nhóm. Thỉnh thoảng ứng dụng nhóm config vào những nhóm được đặt tên (thông thường được gọi là “environments”), được đặt sau những deploy xác định, ví dụ như <code>development</code>, <code>test</code>, and <code>production</code> environments trong Rails. Phương pháp này thì không mở rộng được sạch sẽ (cleanly): như khi nhiều hơn deploy của app được tạo, thì phải cần tên môi trường mới, ví dụ <code>staging</code> hay <code>qa</code>. Khi project (dự án) lớn hơn, depveloper có thêm những environment đặc biệt của riêng họ như <code>joes-staging</code>, kết quả là một tổ hợp lớn của config, làm cho việc quản lý các deploy của app rất dễ phá vỡ.</p>

<p>Trong twelve-factor app, env vars là những điều khiển gọn gàng, mỗi env var đều trực giao với env var khác. Chúng không bao giờ được nhóm lại với nhau như “environments”, thay vì đó chúng được quản lý độc lập với mỗi deploy. Đây làm một mô hình mà có thể mở rộng một cách trôi chảy (smoothly), như là việc app mở rộng nhiều deploy qua thời gian theo lẽ tự nhiên.</p>

<h1 id="4-backing-services-dịch-vụ-phía-sau">4. Backing services (Dịch vụ phía sau)</h1>

<p><em>Coi các backing service (dịch vụ phía sau) như những attached resource (tài nguyên đính kèm)</em></p>

<p>Một <em>backing service</em> là bất kì một service (dịch vụ) nào mà app tiêu thụ qua mạng như một phần vận hành bình thường của nó. Ví dụ gồm datastores (như MySQL hay CouchDB), messaging/queuing systems (ví dụ như RabbitMQ hay Beanstalkd), SMTP services để gửi email ra ngoài (Ví dụ Postfix), và hệ thống caching (Ví dụ Memcached).</p>

<p>Những backing service như cơ sở dữ liệu thì được quản lý một cách truyền thống bởi cùng các quản trị hệ thống giống như triển khai runtime (trình chạy) của app. Ngoài các service được quản lý local, app cũng có thể có những service cung cấp và quản lý bởi bên thứ ba. Ví dụ bao gồm SMTP services (như Postmark), metrics-gathering services (ví dụ như New Relic hay Loggly), binary asset services (Ví dụ Amazon S3), và thậm chí API-accessible consumer services (như Twitter, Google Maps, hay Last.fm).</p>

<p><strong>Mã nguồn cho một twelve-factor app không tạo phân biệt giữa local và các dịch vụ của bên thứ ba.</strong> Để app, và cả local lẫn third party services đều là attached resource, được truy cập thông qua một URL hoặc locator/credentials stored khác trong config. Một deploy của twelve-factor app sẽ có thể được hoán đổi từ một cơ sở dữ liệu MySQL local với một cơ sở dữ liệu quản lý bởi bên thứ 3 (ví dụ Amazon RDS) mà không cần thay đổi code của app. Tương tự như vậy, một máy chủ SMTP local có thể được hoán đổi với một dịch vụ SMTP của bên thứ ba (ví dụ Postmark) mà không phải thay đổi code. Trong cả hai trường hợp, chỉ tài nguyên xử lý trong config là cần thay đổi.</p>

<p>Mỗi backing service riêng biệt là một <em>tài nguyên (resource)</em>. Ví dụ, một CSDL MySQL là một resource, hai CSDL MySQL (sử dụng sharding (phân mảnh) ở tầng ứng dụng) được xác định là hai resource riêng biệt. Twelve-factor app coi những database (CSDL) này như những attached resource, which indicates their loose coupling to the deploy they are attached to.</p>

<p><em>Một production deploy được gắn vào bốn backing serice:</em>
<img src="/images/attached-resources.png" alt="alt text" title="A production deploy attached to four backing services" /></p>

<p>Những tài nguyên có thể được gắn vào hoặc tách ra từ các deploy nếu muốn. Ví dụ, nếu CSDL của app đang bị lỗi do sự cố phần cứng, người quản trị app có thể xoay sang một máy chủ database mới được khôi phục từ bản backup gần nhất. Database của production hiện tại có thể bị tháo ra, và database mới được gắn vào mà không phải thay đổi bất kì dòng code nào.</p>

<h1 id="5-build-release-phát-hành-run">5. Build, release (phát hành), run</h1>

<p><em>Phân chia rõ ràng giữa giai đoạn (stage) build và run</em></p>

<p>Một codebase được chuyển đổi vào một deploy (không phải development) thông qua ba giai đoạn:</p>

<ul>
<li><em>Giai đoạn build</em> là một chuyển đổi mà chuyển từ code repo thành một gói có thể thực thi gọi là một build. Sử dụng một phiên bản của code ở một commit được chỉ định bởi tiến trình phát triển, giai đoạn build sẽ lấy các dependency của bên cung cấp và biên dịch thành chuỗi nhị phân (binaries) và assets (tài sản cố định).</li>
<li><em>Giai đoạn release</em> sẽ lấy bản build được tạo từ giai đoạn build và kết hợp với config hiện tại của deploy. <em>Release</em> nhận được bao gồm cả build và config thì sẵn sàng cho việc thực thi ngay trong môi trường thực thi.</li>
<li><em>Giai đoạn run</em> (cũng được biết như là &ldquo;runtime&rdquo;) chạy app trong môi trường thực thi, bằng việc chạy một số tập tiến trình ứng dụng đối với release đã chọn.</li>
</ul>

<p><em>Code trở thành một build, sau đó sẽ được kết hợp với config để tạo ra một release:</em>
<img src="/images/release.png" alt="alt text" title="Code becomes a build, which is combined with config to create a release" /></p>

<p><strong>Twelve-factor app sử dụng phân chia chặt chẽ giữa các giai đoạn build, release và run.</strong> Ví dụ, không thể thay đổi code ở runtime, vì không có cách nào để truyền những thay đổi này trở lại giai đoạn build.</p>

<p>Công cụ phát triển thường đưa ra công cụ quản lý release, đáng kể nhất là khả năng có thể rollback về một release trước đó. Ví dụ công cụ phát triển Capistrano lưu các release ở một thư mục con (subdirectory) đặt tên là <code>releases</code>, nơi mà bản release hiện tại là một symlink (đường dẫn) đến thư mục release hiện tại. Câu lệnh rollback của nó làm cho việc rollback trở về các bản phát hành trước một cách dễ dàng.</p>

<p>Mọi release luôn luôn nên có một ID duy nhất, ví dụ như sử dụng timestamp (mốc thời gian) phát hành (như <code>2011-04-06-20:32:17</code>) hoặc một số tăng dần (ví dụ <code>v100</code>). Các release là một cuốn sổ cái chỉ cho thêm vào và các release, không thể sửa đổi một khi nó đã được tạo. Chỉ có thể thay đổi bằng cách thêm một release mới.</p>

<p>Các build được khởi tạo bởi developer của app khi code mới được triển khai. Tương phản trong thực thi runtime, có thể tự động xảy ra một số trường hợp ví dụ như một khởi động lại máy chủ, hoặc một tiến trình bị crash (sập) được khởi động lại bởi trình quản lý tiến trình. Vì vậy, giai đoạn chạy nên được giữ thành một vài bước có thể, vì những trục trặc để tránh một app đang chạy có thể bị ngắt giữa đêm khi mà không có developer nào đang thức. Giai đoạn build có thể phức tạp hơn, vì những lỗi luôn luôn cận kề đối với developer đang tạo deploy.</p>

<h1 id="6-processes-tiến-trình">6. Processes (Tiến trình)</h1>

<p><em>Thực thi app như một hoặc nhiều tiến trình phi trạng thái</em></p>

<p>App được thực thi trong môi trường thực thi bởi một hoặc nhiều process (tiến trình).</p>

<p>Trong trường hợp đơn giản, code là một script (đoạn mã) độc lập, môi trường thực thi là một máy tính cá nhân của developer với trình chạy ngôn ngữ đã được cài đặt, và process được khởi chạy thông qua dòng lệnh (ví dụ <code>python my_script.py</code>). Ở trường hợp phức tạp hơn, một production deploy của một app phức tạp có thể sử dụng <a href="#8-concurrency">nhiều kiểu process, được khởi tạo từ 0 đến nhiều process được chạy</a>.</p>

<p><strong>Các process theo twelve-factor thì không có trạng thái và không chia sẻ bất cứ thứ gì.</strong> Bất kỳ dữ liệu cần được lưu vĩnh viễn phải được lưu ở một backing service, thông thường là database.</p>

<p>Không gian nhớ hoặc tệp hệ thống của process có thể được sử dụng như một bộ nhớ đệm ngắn gọn, đơn lẻ. Ví dụ, khi tải về một file lớn, thao trên trên file đấy, và lưu trữ kết quả thao tác vào database. Twelve-factor app không bao giờ giả định rằng bất cứ thứ gì được ghi nhớ đệm (cached) trong bộ nhớ hoặc ổ đĩa sẽ sẵn sàng được dùng bởi một request (yêu cầu) hoặc một job (việc) trong tương lai - với nhiều process của mỗi loại đang chạy, khả năng cao là một request tương lai sẽ được phục vụ bởi một process khác. Thậm chí khi chỉ có một process đang chạy, việc khởi động lại (được gọi khi triển khai code, thay đổi config, hoặc môi trường thực thi thay đổi vị trí của process đến vị trí vật lý khác) cũng sẽ thường xoá toàn bộ trạng thái local (ví dụ bộ nhớ memory và tệp hệ thống file system).</p>

<p>Asset packagers (Trình đóng gói tài sản) như django-assetpackager sử dụng filesystem như một bộ nhớ đệm cho biên dịch asset. Một twelve-factor app sẽ thường thích làm việc biên dịch trong giai đoạn build. Asset packagers ví dụ Jammit và Rails asset pipeline có thể được cấu hình để đóng gói asset trong giai đoạn build.</p>

<p>Một số hệ thống web dựa trên &ldquo;sticky sessions&rdquo; - mà nó sẽ lưu dữ liệu phiên làm việc của user vào bộ nhớ đệm của app’s process và hi vọng các request tương lai đến từ những người dùng giống nhau sẽ được định tuyến vào cùng process. Sticky sessions đã vi phạm phương pháp twelve-factor và không bao giờ nên sử dụng hay dựa vào. Dữ liệu trạng thái session (phiên) là ứng cử viên tốt cho một datastore (vùng lưu dữ liệu), nó đưa ra giới hạn thời gian (time-expiration), ví dụ Memcached hay Redis.</p>

<h1 id="7-port-binding">7. Port binding</h1>

<p><em>Export (xuất)) services qua port (cổng) binding</em></p>

<p>Các ứng dụng web thỉnh thoảng đc thực thi bên trong một webserver. Ví dụ, app PHP có thể được chạy như một mô-đun bên trong Apache HTTPD, hay ứng dụng Java có thể được chạy bên trong Tomcat.</p>

<p><strong>Twelve-factor app thì hoàn toàn self-contained (tự chứa)</strong> và không dựa vào runtime injection của một server vào môi trường thực thi để tạo một dịch vụ giao tiếp web. Web app <strong>xuất giao thức HTTP như một service bằng bằng cách binding đến một cổng</strong>, và lắng nghe request đến từ cổng đó.</p>

<p>Trong môi trường phát triển local, developer truy cập một địa chỉ URL của service ví dụ <code>http://localhost:5000/</code> để truy cập vào service được export bởi app của chúng. Trong môi trường phát triển, một lớp định tuyến xử lý request định tuyến từ một hostname giao tiếp công khai đến những tiến trình web có cổng (port-bound web services).</p>

<p>Thông thường ứng dụng được thực thi triển khai (implement) bằng việc sử dụng khai báo dependency để thêm thư viện webserver vào app, ví dụ như Tornado cho Python, Thin cho Ruby, hay Jetty cho Java và các ngôn ngữ trên nền JVM khác. Việc này xảy ra toàn bộ trong <em>không gian người dùng</em>, đó chính là trong mã nguồn của app. Nhiệm vụ của môi trường thực thi đang binding đến một port là phục vụ các request.</p>

<p>HTTP không phải là service duy nhất có thể xuất bởi port binding. Hầu như bất kì kiểu phần mềm server nào đều có thể chạy thông qua tiến trình binding đến một cổng và chờ đợi request đến. Ví dụ bao gồm ejabberd (speaking XMPP), và Redis (speaking the Redis protocol).</p>

<p>Cũng lưu ý rằng cách tiếp cận port-binding nghĩa là một app có thể trở thành backing service cho một app khác, bằng việc cung cấp địa chỉ URL đến backing app như là một resource xử lý trong config cho app cần dùng.</p>

<h1 id="8-concurrency-đồng-thời">8. Concurrency (Đồng thời)</h1>

<p><em>Mở rộng thông qua mô hình process</em></p>

<p>Any computer program, once run, is represented by one or more processes. Web apps have taken a variety of process-execution forms. For example, PHP processes run as child processes of Apache, started on demand as needed by request volume. Java processes take the opposite approach, with the JVM providing one massive uberprocess that reserves a large block of system resources (CPU and memory) on startup, with concurrency managed internally via threads. In both cases, the running process(es) are only minimally visible to the developers of the app.</p>

<p><em>Scale is expressed as running processes, workload diversity is expressed as process types:</em>
<img src="process-types.png" alt="alt text" title="Scale is expressed as running processes, workload diversity is expressed as process types" /></p>

<p>In the twelve-factor app, processes are a first class citizen. Processes in the twelve-factor app take strong cues from the unix process model for running service daemons. Using this model, the developer can architect their app to handle diverse workloads by assigning each type of work to a process type. For example, HTTP requests may be handled by a web process, and long-running background tasks handled by a worker process.</p>

<p>This does not exclude individual processes from handling their own internal multiplexing, via threads inside the runtime VM, or the async/evented model found in tools such as EventMachine, Twisted, or Node.js. But an individual VM can only grow so large (vertical scale), so the application must also be able to span multiple processes running on multiple physical machines.</p>

<p>The process model truly shines when it comes time to scale out. The share-nothing, horizontally partitionable nature of twelve-factor app processes means that adding more concurrency is a simple and reliable operation. The array of process types and number of processes of each type is known as the process formation.</p>

<p>Twelve-factor app processes should never daemonize or write PID files. Instead, rely on the operating system’s process manager (such as systemd, a distributed process manager on a cloud platform, or a tool like Foreman in development) to manage output streams, respond to crashed processes, and handle user-initiated restarts and shutdowns.</p>

<p>Dịch bởi: <code>code2080</code></p>

        </div>

        
        
        <div class="article-toc" >
            <nav id="TableOfContents">
<ul>
<li><a href="#mở-đầu">MỞ ĐẦU</a>
<ul>
<li><a href="#giới-thiệu">Giới thiệu</a></li>
<li><a href="#khởi-nguồn">Khởi nguồn</a></li>
<li><a href="#ai-nên-đọc-tài-liệu-này">Ai nên đọc tài liệu này?</a></li>
</ul></li>
<li><a href="#1-codebase-toàn-bộ-mã-nguồn-dự-án">1. Codebase (Toàn bộ mã nguồn dự án)</a></li>
<li><a href="#2-dependencies-các-phụ-thuộc">2. Dependencies (Các phụ thuộc)</a></li>
<li><a href="#3-config-cấu-hình">3. Config (Cấu hình)</a></li>
<li><a href="#4-backing-services-dịch-vụ-phía-sau">4. Backing services (Dịch vụ phía sau)</a></li>
<li><a href="#5-build-release-phát-hành-run">5. Build, release (phát hành), run</a></li>
<li><a href="#6-processes-tiến-trình">6. Processes (Tiến trình)</a></li>
<li><a href="#7-port-binding">7. Port binding</a></li>
<li><a href="#8-concurrency-đồng-thời">8. Concurrency (Đồng thời)</a></li>
</ul>
</nav>
        </div>
        
        

        


        
        <footer class="article-footer">
            <ul class="article-tag-list">
                
                <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="https://code2080.com/tags/software-development">software development
                    </a>
                </li>
                
                <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="https://code2080.com/tags/translation">translation
                    </a>
                </li>
                
            </ul>
        </footer>
        
    </div>
    <nav id="article-nav">
    
    
    <a href="/about/" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title">About me&nbsp;<span>&gt;</span></div>
    </a>
    
</nav>
</article>

        
    </section>
    <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 Code Twenty Eighty.
            Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/carsonip/hugo-theme-minos">Minos</a>.
        </div>
    </div>
    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css" integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin="anonymous"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>
</div>
</body>
</html>
