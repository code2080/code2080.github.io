<!DOCTYPE html>
<html>
<head>
    <title>Xây dựng ứng dụng theo 12 yếu tố (Twelve-Factor App) // Code Twenty Eighty</title>

        <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="description" content="">
    <meta name="keywords" content="">
    <meta name="author" content="">
        <meta property="og:title" content="Xây dựng ứng dụng theo 12 yếu tố (Twelve-Factor App)" />
    <meta property="og:description" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:url" content="https://code2080.com/12-factor/" />
    

    <link href="" rel="alternate" type="application/rss+xml" title="Code Twenty Eighty" />
    <link rel="shortcut icon" href="/favicon.png">

    <link href="https://code2080.com/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="https://code2080.com/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="https://code2080.com/css/style.css">

    <link href="http://gmpg.org/xfn/11" rel="profile">
    
    <meta name="generator" content="Hugo 0.48" />
</head>


<body>
<div id="container">
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="https://code2080.com/">Code Twenty Eighty</a>
            <nav id="main-nav">
                
            </nav>
            <nav id="sub-nav">
                <div id="search-form-wrap">
                </div>
            </nav>
        </div>
    </div>
</header>
    <section id="main" class="outer">
        <article class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        <header class="article-header">
            <h1 class="article-title" itemprop="name">Xây dựng ứng dụng theo 12 yếu tố (Twelve-Factor App)</h1>
        </header>
        
        <div class="article-meta">
            <a href="/12-factor/" class="article-date">
                <time datetime='2018-09-19T00:46:35.000&#43;07:00' itemprop="datePublished">2018-09-19</time>
            </a>
            
            
            
        </div>
        <div class="article-entry" itemprop="articleBody">
            

<p>Nguồn: <a href="https://12factor.net/">https://12factor.net/</a></p>

<h1 id="mở-đầu">MỞ ĐẦU</h1>

<h2 id="giới-thiệu">Giới thiệu</h2>

<p>Trong kỷ nguyên hiện đại, phần mềm thông thường được cung cấp như một dịch vụ: được gọi là <em>web apps</em> (những ứng dụng web), hay là <em>software-as-a-service</em> (phần mềm như một dịch vụ). App (ứng dụng) xây dựng theo twelve-factor là một phương pháp học để xây dựng app như vậy, bao gồm:</p>

<ul>
<li>Sử dụng định dạng <strong>declarative</strong> cho thiết lập tự động, để giảm thiểu tối đa thời gian và công sức cho những lập trình viên mới tham gia vào dự án;</li>
<li>Có <strong>giao kèo sạch</strong> (clean contract) với hệ thống vận hành ở bên dưới, đưa ra <strong>tối đa tính khả chuyển</strong> (maximum portability) giữa các môi trường thực thi;</li>
<li>Tiện dụng cho <strong>phát triển</strong> trên <strong>nền tảng điện toán đám mây</strong> hiện đại, loại bỏ sự cấp thiết cho các máy chủ và những người quản trị hệ thống;</li>
<li><strong>Giảm thiểu tối đa sự khác nhau</strong> giữa development (phát triển) và production (sản phẩm), kích hoạt tính năng <strong>phát triển liên tục</strong> (CD, continuous deployment) để tối đa tốc độ phát triển app;</li>
<li>Và có thể <strong>mở rộng</strong> mà không cần thay đổi đáng kể nào về công cụ, kiến trúc, hay các phương pháp phát triển (development practices).</li>
</ul>

<p>Phương pháp twelve-factor có thể áp dụng cho app viết bằng bất cứ ngôn ngữ nào, và sử dụng bất kì sự kết hợp nào của các dịch vụ ở backend (như cơ sở dữ liệu, queue, memory cache,&hellip;).</p>

<h2 id="khởi-nguồn">Khởi nguồn</h2>

<p>Những người đóng góp cho tài liệu này đều đã trực tiếp gặp phải những rắc rối trong sự phát triển một cũng như hàng trăm app, và gián tiếp chứng kiến sự phát triển, vận hành, và mở rộng của hàng trăm triệu app thông qua công việc của chúng tôi ở nền tảng Heroku.</p>

<p>Tài liệu này tổng hợp tất cả kinh nghiệm và sự quan sát của chúng tôi trong thế giới rộng lớn của software-as-a-service app. Nó là một tam phân của những thực hành ý tưởng trong phát triển app, đặc biệt chú ý đến sự dynamic (năng động) của việc phát triển cơ bản của một app qua thời gian, sự dynamic của cộng tác giữa các developer (nhà phát triển) làm việc trên cùng mã nguồn app, và <a href="http://blog.heroku.com/archives/2011/6/28/the_new_heroku_4_erosion_resistance_explicit_contracts/">tránh chi phí của việc sói mòn phần mềm</a>.</p>

<p>Động lực của chúng tôi là để nâng cao nhận thức về một số lỗi truyền thống mà chúng ta thấy trong phát triển app hiện đại, để cung cấp những ngôn từ chung để thảo luận về những vấn đề đó, và để đưa ra một tập rộng các giải pháp mang tính khái niệm cho những vấn đề đó với những thuật ngữ kèm theo. Định dạng này được lấy cảm hứng bởi cuốn sách <a href="https://books.google.com/books/about/Patterns_of_enterprise_application_archi.html?id=FyWZt5DdvFkC">Patterns of Enterprise Application Architecture and Refactoring</a> của Martin Fowler.</p>

<h2 id="ai-nên-đọc-tài-liệu-này">Ai nên đọc tài liệu này?</h2>

<p>Bất kỳ developer nào, mà xây dựng app chạy như là một dịch vụ. Kỹ sư hệ thống, người triển khai và quản lý các app như vậy.</p>

<h1 id="1-codebase-toàn-bộ-mã-nguồn-dự-án">1. Codebase (Toàn bộ mã nguồn dự án)</h1>

<p><strong>Một codebase thì được theo dõi trong kiểm soát sửa đổi, và có nhiều bản triển khai</strong></p>

<p>Một twelve-factor app thì luôn luôn được theo dõi trong một hệ thống quản lý phiên bản, ví dụ như Git, Mercurial, hoặc Subversion. Một bản sao chép của cơ sở dữ liệu theo dõi sửa đổi (revision tracking database) thì được biết như là một <em>code repository</em>, hay thường gọi tắt là <em>code repo</em> hoặc chỉ là <em>repo</em>.</p>

<p>Một <em>codebase</em> có thể là bất kì một repo đơn nào (trong một hệ thống kiểm soát sửa đổi tập trung như Subversion), hoặc bất kì một tập repo nào được chia sẻ root commit (trong một hệ thống kiểm soát sửa đổi phi tập trung như Git).</p>

<p>Luôn luôn có sự tương quan một-một giữa codebase và app:</p>

<p><em>Mỗi codebase có nhiều deploy:</em>
<img src="/images/codebase-deploys.png" alt="alt text" title="One codebase maps to many deploys" /></p>

<ul>
<li><p>Nếu có nhiều codebase, thì nó không phải một app, mà là một hệ thống phân tán. Mỗi thành phần trong một hệ thống phân tán là một app, và mỗi thành phần đó có thể tuân theo một cách cá nhân với twelve-factor.</p></li>

<li><p>Nhiều app chia sẻ mã giống nhau là một sự vi pham trong twelve-factor. Giải pháp ở đây là để những phần chia sẻ code chung vào thành những thư viện, mà có thể được bao hàm thông qua trình quản lý phụ thuộc (<a href="#2-dependencies-các-phụ-thuộc">dependency manager</a>).</p></li>
</ul>

<p>Chỉ có duy nhất một codebase với mỗi app, nhưng sẽ có nhiều deploy (triển khai) của một app. Một <em>deploy</em> là một instance (thực thể) của app, điển hình nó có thể là một production site, và là một hoặc nhiều staging sites. Thêm nữa, mọi developer đều có một bản sao chép của app chạy ở môi trường phát triển local của họ, mỗi trong số đó cũng đều được coi là một bản deploy.</p>

<p>Codebase thì giống nhau ở tất cả các deploy, mặc dù các phiên bản khác nhau có thể được active ở mỗi deploy. Ví dụ, một developer có một số commit chưa được deploy đến staging; staging thì cũng có một số commit chưa được deploy đến production. Nhưng chúng đều chia sẻ codebase giống nhau, ví vậy để chúng có thể nhận biết được như là các deploy khác nhau của cùng một app.</p>

<h1 id="2-dependencies-các-phụ-thuộc">2. Dependencies (Các phụ thuộc)</h1>

<p><em>Khai báo rõ ràng và cô lập các dependency (phụ thuộc)</em></p>

<p>Hầu hết các ngôn ngữ lập trình đều đưa ra hệ thống quản lý gói (packaging system) cho việc phân phối các thư viện hỗ trợ, ví dụ như CPAN cho Perl, Rubygems for Ruby, NPM cho NodeJS, Pip cho Python. Thư viện được cài đặt thông qua một hệ thống quản lý gói có thể được cài đặt trong phạm vi toàn hệ thống (system-wide) (được biết như là &ldquo;site packages&rdquo;) hoặc giới hạn phạm vi trong thư mục chứa app (được biết như là &ldquo;vendoring&rdquo; hay &ldquo;bundling&rdquo;).</p>

<p><strong>Một twelve-factor app không bao giờ tin vào sự tồn tại ngầm của các gói trên toàn hệ thống (system-wide packages)</strong>. Nó khai báo tất cả các dependency, trọn vẹn và chính xác, thông qua một bản kê <em>khai báo dependency (dependency declaration)</em>. Hơn nữa nó sử dụng một công cụ <em>cô lập dependency (dependency isolation)</em> trong quá trình thực thi, để chắc rằng không có dependency ngầm nào &ldquo;bị rò rỉ vào trong&rdquo; (&ldquo;leak in&rdquo;) từ hệ thống xung quanh. Bản đặc tả dependency đầy đủ và rõ ràng được áp dụng đồng nhất với cả production và development.</p>

<p>Ví dụ, Bundler (Trình đóng gói) cho Ruby đưa ra định dạng bản kê <code>Gemfile</code> cho khai báo dependency và <code>bundle exec</code> cho các cô lập dependency. Trong Python, có 2 công cụ riêng biệt cho các bước này - Pip sử dụng cho khai báo, Virtualenv cho cô lập. Thậm chí C có Autoconf cho khai báo dependency, và liên kết tĩnh (static linking) có thể cung cấp cô lập denpendency. Bất kể toolchain nào (tập công cụ lập trình), khai báo và cô lập dependency phải luôn luôn được sử dụng cùng nhau - chỉ cái này hoặc cái kia là không đủ thoả mãn twelve-factor.</p>

<p>Một lợi ích của khai báo dependency rõ ràng là nó làm đơn giản việc thiết lập cho những developer mới tham gia vào app. Developer mới có thể check out codebase của app sang máy phát triển của họ, chỉ yêu cầu có trình chạy của ngôn ngữ (language runtime) và trình quản lý dependency được cài đặt như điều kiện trước hết. Họ sẽ có thể thiết lập mọi thứ cần thiết để chạy mã nguồn app với <em>câu lệnh build</em> xác định. Ví dụ, câu lệnh build cho Ruby/Bundler là <code>bundle install</code>, còn cho Clojure/leiningen là <code>lein deps</code>.</p>

<p>Twelve-factor app cũng không dựa vào tồn tại ngầm của bất kỳ công cụ hệ thống nào. Ví dụ bao gồm shelling out đến ImageMagick hoặc <code>curl</code>. Trong khi những công cụ này có thể tổn tại trên nhiều hoặc thậm chí hầu hết hệ thống, tuy nhiên không có gì đảm bảo rằng chúng sẽ tồn tại trên tất cả hệ thống nơi mà app của bạn có thể chạy trong tương lai, hoặc liệu phiên bản được tìm thấy trên một hệ thống trong tương lai sẽ tương thích với app. Nếu app cần shell out đến một công cụ hệ thống, thì công cụ này nên được cung cấp trong app.</p>

<h1 id="3-config-cấu-hình">3. Config (Cấu hình)</h1>

<p><em>Lưu trữ cấu hình trong môi trường</em></p>

<p>Một cấu hình app là mọi thứ có khả năng thay đổi giữa các bản deploy (staging, production, developer environments, &hellip;). Bao gồm:</p>

<ul>
<li>Tài nguyên xử lý database, Memcached, và các dịch vụ đằng sau khác (backing services)</li>
<li>Uỷ nhiệm đến dịch vụ bên ngoài (external services) như Amazon S3 hay Twitter</li>
<li>Các giá trị trên mỗi deploy như hostname kiểu mẫu cho deploy</li>
</ul>

<p>Các app thỉnh thoảng lưu trữ cấu hình như hằng số trong code. Điều này vi phạm twelve-factor, nó yêu cầu sự <strong>phân chia chặt chẽ của cấu hình từ code</strong> (strict separation of config from code). Cấu hình về thực chất sẽ thay đổi qua các deploy, code (mã nguồn) không làm điều này.</p>

<p>Một bài kiểm thử (litmus test) là liệu một app có tất cả cấu hình đúng được đặt ngoài code không chính là liệu codebase có thể trở thành open source (mã nguồn mở) bất cứ lúc nào không, mà cần thoả hiệp bất cứ uỷ nhiệm (credential) nào.</p>

<p>Chú ý rằng định nghĩa này của &ldquo;config&rdquo; không bao gồm cho cấu hình ứng dụng bên trong (internal application config), ví dụ <code>config/routes.rb</code> trong Rails, hay cách mà những mô-đun code được kết nối trong Spring. Kiểu này của config không thay đổi giữa các deploy, vì vậy tốt nhất là để nó ở trong code.</p>

<p>Một cách tiếp cận khác để config là sử dụng các tệp cấu hình (config files) mà không được đánh dấu vào trong trình kiểm soát mã nguồn, ví dụ như <code>config/database.yml</code> trong Rails. Việc này là cải thiện rất lớn thay cho việc sử dụng hằng số mà được đánh dấu trong code repo, nhưng nó vẫn có những điểm yếu; là rất dễ mắc sai lầm đánh dấu một config file trong repo; có một xu hướng cho những file config bị phân tán ở các nơi khác nhau và định dạng khác nhau, làm cho việc xem và quản lý tất cả các config ở một nơi khó khăn. Hơn nữa, những định dạng này hướng theo đặc tả của ngôn ngữ hoặc framework.</p>

<p><strong>Twelve-factor app lưu config trong biến môi trường</strong> (<em>environment variables</em>, thường viết ngắn gọn là <em>env vars</em> hay <em>env</em>). Env vars dễ dàng thay đổi giữa các deploy mà không phải thay đổi code; không giống như file config, chúng chỉ có nguy cơ nhỏ không may bị đánh dấu trong code repo; và cũng không giống như file config tuỳ chỉnh, hay các cơ chế config khác ví dụ Java System Properties, chúng là theo chuẩn không thể biết của ngôn ngữ lập trình và OS (hệ điều hành) (language- and OS-agnostic standard).</p>

<p>Một mặt khác của quản lý config là đặt nhóm. Thỉnh thoảng ứng dụng nhóm config vào những nhóm được đặt tên (thông thường được gọi là “environments”), được đặt sau những deploy xác định, ví dụ như <code>development</code>, <code>test</code>, and <code>production</code> environments trong Rails. Phương pháp này thì không mở rộng được sạch sẽ (cleanly): như khi nhiều hơn deploy của app được tạo, thì phải cần tên môi trường mới, ví dụ <code>staging</code> hay <code>qa</code>. Khi project (dự án) lớn hơn, depveloper có thêm những environment đặc biệt của riêng họ như <code>joes-staging</code>, kết quả là một tổ hợp lớn của config, làm cho việc quản lý các deploy của app rất dễ phá vỡ.</p>

<p>Trong twelve-factor app, env vars là những điều khiển gọn gàng, mỗi env var đều trực giao với env var khác. Chúng không bao giờ được nhóm lại với nhau như “environments”, thay vì đó chúng được quản lý độc lập với mỗi deploy. Đây làm một mô hình mà có thể mở rộng một cách trôi chảy (smoothly), như là việc app mở rộng nhiều deploy qua thời gian theo lẽ tự nhiên.</p>

<h1 id="4-backing-services-dịch-vụ-phía-sau">4. Backing services (Dịch vụ phía sau)</h1>

<p><em>Coi các backing service (dịch vụ phía sau) như những attached resource (tài nguyên đính kèm)</em></p>

<p>Một <em>backing service</em> là bất kì một service (dịch vụ) nào mà app tiêu thụ qua mạng như một phần vận hành bình thường của nó. Ví dụ gồm datastores (như MySQL hay CouchDB), messaging/queuing systems (ví dụ như RabbitMQ hay Beanstalkd), SMTP services để gửi email ra ngoài (Ví dụ Postfix), và hệ thống caching (Ví dụ Memcached).</p>

<p>Những backing service như cơ sở dữ liệu thì được quản lý một cách truyền thống bởi cùng các quản trị hệ thống giống như triển khai runtime (trình chạy) của app. Ngoài các service được quản lý local, app cũng có thể có những service cung cấp và quản lý bởi bên thứ ba. Ví dụ bao gồm SMTP services (như Postmark), metrics-gathering services (ví dụ như New Relic hay Loggly), binary asset services (Ví dụ Amazon S3), và thậm chí API-accessible consumer services (như Twitter, Google Maps, hay Last.fm).</p>

<p><strong>Mã nguồn cho một twelve-factor app không tạo phân biệt giữa local và các dịch vụ của bên thứ ba.</strong> Để app, và cả local lẫn third party services đều là attached resource, được truy cập thông qua một URL hoặc locator/credentials stored khác trong config. Một deploy của twelve-factor app sẽ có thể được hoán đổi từ một cơ sở dữ liệu MySQL local với một cơ sở dữ liệu quản lý bởi bên thứ 3 (ví dụ Amazon RDS) mà không cần thay đổi code của app. Tương tự như vậy, một máy chủ SMTP local có thể được hoán đổi với một dịch vụ SMTP của bên thứ ba (ví dụ Postmark) mà không phải thay đổi code. Trong cả hai trường hợp, chỉ tài nguyên xử lý trong config là cần thay đổi.</p>

<p>Mỗi backing service riêng biệt là một <em>tài nguyên (resource)</em>. Ví dụ, một CSDL MySQL là một resource, hai CSDL MySQL (sử dụng sharding (phân mảnh) ở tầng ứng dụng) được xác định là hai resource riêng biệt. Twelve-factor app coi những database (CSDL) này như những attached resource, which indicates their loose coupling to the deploy they are attached to.</p>

<p><em>Một production deploy được gắn vào bốn backing serice:</em>
<img src="/images/attached-resources.png" alt="alt text" title="A production deploy attached to four backing services" /></p>

<p>Những tài nguyên có thể được gắn vào hoặc tách ra từ các deploy nếu muốn. Ví dụ, nếu CSDL của app đang bị lỗi do sự cố phần cứng, người quản trị app có thể xoay sang một máy chủ database mới được khôi phục từ bản backup gần nhất. Database của production hiện tại có thể bị tháo ra, và database mới được gắn vào mà không phải thay đổi bất kì dòng code nào.</p>

<h1 id="5-build-release-phát-hành-run">5. Build, release (phát hành), run</h1>

<p><em>Phân chia rõ ràng giữa giai đoạn (stage) build và run</em></p>

<p>Một codebase được chuyển đổi vào một deploy (không phải development) thông qua ba giai đoạn:</p>

<ul>
<li><em>Giai đoạn build</em> là một chuyển đổi mà chuyển từ code repo thành một gói có thể thực thi gọi là một build. Sử dụng một phiên bản của code ở một commit được chỉ định bởi tiến trình phát triển, giai đoạn build sẽ lấy các dependency của bên cung cấp và biên dịch thành chuỗi nhị phân (binaries) và assets (tài sản cố định).</li>
<li><em>Giai đoạn release</em> sẽ lấy bản build được tạo từ giai đoạn build và kết hợp với config hiện tại của deploy. <em>Release</em> nhận được bao gồm cả build và config thì sẵn sàng cho việc thực thi ngay trong môi trường thực thi.</li>
<li><em>Giai đoạn run</em> (cũng được biết như là &ldquo;runtime&rdquo;) chạy app trong môi trường thực thi, bằng việc chạy một số tập tiến trình ứng dụng đối với release đã chọn.</li>
</ul>

<p><em>Code trở thành một build, sau đó sẽ được kết hợp với config để tạo ra một release:</em>
<img src="/images/release.png" alt="alt text" title="Code becomes a build, which is combined with config to create a release" /></p>

<p><strong>Twelve-factor app sử dụng phân chia chặt chẽ giữa các giai đoạn build, release và run.</strong> Ví dụ, không thể thay đổi code ở runtime, vì không có cách nào để truyền những thay đổi này trở lại giai đoạn build.</p>

<p>Công cụ phát triển thường đưa ra công cụ quản lý release, đáng kể nhất là khả năng có thể rollback về một release trước đó. Ví dụ công cụ phát triển Capistrano lưu các release ở một thư mục con (subdirectory) đặt tên là <code>releases</code>, nơi mà bản release hiện tại là một symlink (đường dẫn) đến thư mục release hiện tại. Câu lệnh rollback của nó làm cho việc rollback trở về các bản phát hành trước một cách dễ dàng.</p>

<p>Mọi release luôn luôn nên có một ID duy nhất, ví dụ như sử dụng timestamp (mốc thời gian) phát hành (như <code>2011-04-06-20:32:17</code>) hoặc một số tăng dần (ví dụ <code>v100</code>). Các release là một cuốn sổ cái chỉ cho thêm vào và các release, không thể sửa đổi một khi nó đã được tạo. Chỉ có thể thay đổi bằng cách thêm một release mới.</p>

<p>Các build được khởi tạo bởi developer của app khi code mới được triển khai. Tương phản trong thực thi runtime, có thể tự động xảy ra một số trường hợp ví dụ như một khởi động lại máy chủ, hoặc một tiến trình bị crash (sập) được khởi động lại bởi trình quản lý tiến trình. Vì vậy, giai đoạn chạy nên được giữ thành một vài bước có thể, vì những trục trặc để tránh một app đang chạy có thể bị ngắt giữa đêm khi mà không có developer nào đang thức. Giai đoạn build có thể phức tạp hơn, vì những lỗi luôn luôn cận kề đối với developer đang tạo deploy.</p>

<h1 id="6-processes-tiến-trình">6. Processes (Tiến trình)</h1>

<p><em>Thực thi app như một hoặc nhiều tiến trình phi trạng thái</em></p>

<p>App được thực thi trong môi trường thực thi bởi một hoặc nhiều process (tiến trình).</p>

<p>Trong trường hợp đơn giản, code là một script (đoạn mã) độc lập, môi trường thực thi là một máy tính cá nhân của developer với trình chạy ngôn ngữ đã được cài đặt, và process được khởi chạy thông qua dòng lệnh (ví dụ <code>python my_script.py</code>). Ở trường hợp phức tạp hơn, một production deploy của một app phức tạp có thể sử dụng <a href="#8-concurrency-đồng-thời">nhiều kiểu process, được khởi tạo từ 0 đến nhiều process được chạy</a>.</p>

<p><strong>Các process theo twelve-factor thì không có trạng thái và không chia sẻ bất cứ thứ gì.</strong> Bất kỳ dữ liệu cần được lưu vĩnh viễn phải được lưu ở một backing service, thông thường là database.</p>

<p>Không gian nhớ hoặc tệp hệ thống của process có thể được sử dụng như một bộ nhớ đệm ngắn gọn, đơn lẻ. Ví dụ, khi tải về một file lớn, thao trên trên file đấy, và lưu trữ kết quả thao tác vào database. Twelve-factor app không bao giờ giả định rằng bất cứ thứ gì được ghi nhớ đệm (cached) trong bộ nhớ hoặc ổ đĩa sẽ sẵn sàng được dùng bởi một request (yêu cầu) hoặc một job (việc) trong tương lai - với nhiều process của mỗi loại đang chạy, khả năng cao là một request tương lai sẽ được phục vụ bởi một process khác. Thậm chí khi chỉ có một process đang chạy, việc khởi động lại (được gọi khi triển khai code, thay đổi config, hoặc môi trường thực thi thay đổi vị trí của process đến vị trí vật lý khác) cũng sẽ thường xoá toàn bộ trạng thái local (ví dụ bộ nhớ memory và tệp hệ thống file system).</p>

<p>Asset packagers (Trình đóng gói tài sản) như django-assetpackager sử dụng filesystem như một bộ nhớ đệm cho biên dịch asset. Một twelve-factor app sẽ thường thích làm việc biên dịch trong giai đoạn build. Asset packagers ví dụ Jammit và Rails asset pipeline có thể được cấu hình để đóng gói asset trong giai đoạn build.</p>

<p>Một số hệ thống web dựa trên &ldquo;sticky sessions&rdquo; - mà nó sẽ lưu dữ liệu phiên làm việc của user vào bộ nhớ đệm của app’s process và hi vọng các request tương lai đến từ những người dùng giống nhau sẽ được định tuyến vào cùng process. Sticky sessions đã vi phạm phương pháp twelve-factor và không bao giờ nên sử dụng hay dựa vào. Dữ liệu trạng thái session (phiên) là ứng cử viên tốt cho một datastore (vùng lưu dữ liệu), nó đưa ra giới hạn thời gian (time-expiration), ví dụ Memcached hay Redis.</p>

<h1 id="7-port-binding">7. Port binding</h1>

<p><em>Export (xuất)) services qua port (cổng) binding</em></p>

<p>Các ứng dụng web thỉnh thoảng đc thực thi bên trong một webserver. Ví dụ, app PHP có thể được chạy như một mô-đun bên trong Apache HTTPD, hay ứng dụng Java có thể được chạy bên trong Tomcat.</p>

<p><strong>Twelve-factor app thì hoàn toàn self-contained (tự chứa)</strong> và không dựa vào runtime injection của một server vào môi trường thực thi để tạo một dịch vụ giao tiếp web. Web app <strong>xuất giao thức HTTP như một service bằng bằng cách binding đến một cổng</strong>, và lắng nghe request đến từ cổng đó.</p>

<p>Trong môi trường phát triển local, developer truy cập một địa chỉ URL của service ví dụ <code>http://localhost:5000/</code> để truy cập vào service được export bởi app của chúng. Trong môi trường phát triển, một lớp định tuyến xử lý request định tuyến từ một hostname giao tiếp công khai đến những tiến trình web có cổng (port-bound web services).</p>

<p>Thông thường ứng dụng được thực thi triển khai (implement) bằng việc sử dụng khai báo dependency để thêm thư viện webserver vào app, ví dụ như Tornado cho Python, Thin cho Ruby, hay Jetty cho Java và các ngôn ngữ trên nền JVM khác. Việc này xảy ra toàn bộ trong <em>không gian người dùng</em>, đó chính là trong mã nguồn của app. Nhiệm vụ của môi trường thực thi đang binding đến một port là phục vụ các request.</p>

<p>HTTP không phải là service duy nhất có thể xuất bởi port binding. Hầu như bất kì kiểu phần mềm server nào đều có thể chạy thông qua tiến trình binding đến một cổng và chờ đợi request đến. Ví dụ bao gồm ejabberd (speaking XMPP), và Redis (speaking the Redis protocol).</p>

<p>Cũng lưu ý rằng cách tiếp cận port-binding nghĩa là một app có thể trở thành backing service cho một app khác, bằng việc cung cấp địa chỉ URL đến backing app như là một resource xử lý trong config cho app cần dùng.</p>

<h1 id="8-concurrency-đồng-thời">8. Concurrency (Đồng thời)</h1>

<p><em>Mở rộng thông qua mô hình process</em></p>

<p>Bất kỳ chương trình máy tính nào, khi chạy, đều được biểu diễn bởi một hoặc nhiều process. Web app thì đã lấy đủ kiểu biểu mẫu thực thi process khác nhau. Ví dụ, Các PHP process chạy như một process con của Apache, được chạy theo yêu cầu cần bởi lượng request. Các Java process thì tiếp cận ngược lại, với JVM cung cấp một uberprocess lớn mà dự trữ một khối lớn của tài nguyên hệ thống khi khởi chạy, với concurrency được quản lý nội bộ qua các luồng. Trong cả hai trường hợp, các process đang chạy chỉ hiển thị tối thiểu với các lập trình viên ứng dụng.</p>

<p><em>Sự mở rộng được thể hiện như các process đang chạy, sự đa dạng của workload (tải công việc) thì được thể hiện như các kiểu của process:</em>
<img src="/images/process-types.png" alt="alt text" title="Scale is expressed as running processes, workload diversity is expressed as process types" /></p>

<p>Trong twelve-factor app, các process được coi là các công dân hạng nhất. Các process trong twelve-factor app lấy các gợi ý mạnh mẽ từ mô hình process của unix cho các service daemon (dịch vụ của chương trình chạy nền) đang chạy. Sử dụng mô hình này, lập trình viên có thể kiến trúc app của họ để xử lý các workload đa dạng bằng cách gán mỗi kiểu work (công việc) cho một kiểu process. Ví dụ, các HTTP request (yêu cầu theo giao thức HTTP) có thể được xử lý bởi các web process, và các task (nhiệm vụ) chạy nền lâu (long-running) được xử lý bởi mộ worker process.</p>

<p>Điều này không loại trừ việc những process riêng rẽ xử lý công việc nội bộ cồng kềnh của chúng, thông qua các luồng bên trong quá trình chạy của máy ảo (runtime VM), hoặc mô hình async/evented (bất đồng bộ/hướng sự kiện) được tìm thấy trong các công cụ ví dụ như EventMachine, Twisted, hay Node.js. Nhưng một VM (Virtual Machine, máy ảo) riêng rẽ chỉ có thể phát triển quá lớn (theo chiều dọc), vì vậy ứng dụng cũng phải có khả năng mở rộng nhiều process chạy trên nhiều máy tính vật lý.</p>

<p>Mô hình process chỉ thực sự toả sáng khi nói đến thời gian để mở rộng quy mô. Không chia sẻ, tính chất phân chia theo chiều ngang của process của twelve-factor app nghĩa là việc thêm concurrency là một thao tác đơn giản và đáng tin cậy. Một mảng các kiểu process và số lượng process theo từng kiểu được gọi là <em>process formation</em>.</p>

<p>Những process của twelve-factor app không nên cho chạy nền của hệ thống (daemonize) hoặc viết vào tệp PID. Thay vì đó, chỉ dựa trên trình quản lý process của hệ điều hành (ví dụ systemd, một trình quản lý process phân tán trên nền tảng cloud, hoặc một công cụ như Foreman trong quá trình phát triển) để quản lý <a href="#11-logs-các-ghi-chép">các dòng dữ liệu đầu ra</a>, phản hồi lại các process bị hỏng (crashed), và xử lý các hành động tắt và khởi động lại do người dùng khởi tạo.</p>

<h1 id="9-disposability-khả-năng-sẵn-sàng">9. Disposability (Khả năng sẵn sàng)</h1>

<p><em>Tối đa sự mạnh mẽ với khởi động nhanh và tắt nhã nhặn</em></p>

<p>Process của twelve-factor app thì có khả năng sẵn sàng, nghĩa là chúng có thể bật hoặc tắt khi có thông báo tại một thời điểm nào đấy. Điều này làm dễ dàng cho việc mở rộng co giãn nhanh, triển khai nhanh chóng khi thay đổi code hoặc config, và sự chắc chắn của các deploy của production.</p>

<p>Các process nên cố gắng giảm tối đa thời gian khởi động. Lý tưởng là, một process mất vài giây từ khi chạy câu lệnh khởi động đến khi process chạy và sẵn sàng nhận request và job. Thời gian khởi động ngắn cung cấp sự nhanh nhẹn hơn cho tiến trình phát hành và mở rộng; và nó tăng cường sự mạnh mẽ, bởi vì trình quản lý process có thể dễ dàng hơn trong việc di chuyển các process đến máy tính vật lý mới khi được bảo hành.</p>

<p>Các process tắt nhã nhặn khi chúng nhận một tín hiện SIGTERM (SIGTERM signal) từ trình quản lý process. Với một web process, tắt nhã nhặn đạt được bởi việc ngừng lắng nghe trên các cổng dịch vụ (bằng cách ấy từ chối bất kỳ các request mới nào), cho phép bất kì request hiện tại nào kết thúc, và sau đó thoát. Ngụ ý trong mô hình này là HTTP request thì ngắn (không quá vài giây), hoặc trong trường hợp long-polling, máy khách sẽ cố gắng kết nối lại khi mất kết nối.</p>

<p>Với một worker process, tắt nhã nhặn đạt được bằng việc trả lại job hiện tại vào hàng đợi (work queue). Ví dụ, trên RabbitMQ worker có thể gửi một NACK; trên Beanstalkd, job được trả lại hàng đợi tự động khi một worker bị mất kết nối. Hệ thống Lock-based ví dụ Delayed Job cần chắc chắn nhả lock của chúng trên bản ghi job. Ngụ ý trong mô hình này là tất cả các job có thể dùng lại được, mà thông thường đạt được được bởi bao kết quả trong một giao dịch (transaction), hoặc làm cho thao tác không thay đổi giá trị.</p>

<p>Các process cũng phải mạnh mẽ để chống lại việc hỏng đột ngột (sudden death), trong trường hợp một hỏng hóc của phần cứng bên dưới. Tuy điều này hiếm khi xảy ra hơn so với việc tắt nhã nhặn với SIGTERM, nhưng nó vẫn có thể xảy ra. Một cách tiếp cận khuyến khích là sử dụng một backend hàng đợi mạnh mẽ, ví dụ Beanstalkd, mà có thể gửi trả job vào hàng đợi khi client mất kết nối hoặc time out. Dù bằng cách nào, một twelve-factor app cũng phải được kiến trúc để xử lý việc ngắt kết nối không mong muốn, không nhã nhặn. Thiết kế crash-only lấy khái niệm này cho kết luận logic của nó.</p>

<h1 id="10-dev-prod-parity-tương-đồng-giữa-phát-triển-và-sản-phẩm">10. Dev/prod parity (Tương đồng giữa phát triển và sản phẩm)</h1>

<p><em>Giữ môi trường development, staging, and production giống nhau nhất có thể</em></p>

<p>Trong lịch sử, đã có những lỗ hổng thực tế giữa development (một developer thực hiện những chỉnh sửa trực tiếp lên bản deploy local của app) và production (một deploy đang chạy của app được truy cập bởi người dùng cuối). Những lỗ hổng này biểu thị trong ba vùng:</p>

<ul>
<li><strong>Lỗ hổng thời gian</strong>: Một developer có thể làm việc trên code mất nhiều ngày, nhiều tuần, thậm chí nhiều tháng trước khi đưa lên production.</li>
<li><strong>Lỗ hổng con người</strong>: Các developer viết code còn kỹ sư hệ thống triển khai nó.</li>
<li><strong>Lỗ hổng công cụ</strong>: Các developer có thể sử dụng một stack (nhóm) như Nginx, SQLite, và OS X, trong khi deploy trên production sử dụng Apache, MySQL, và Linux.</li>
</ul>

<p><strong>Twelve-factor app được thiết kế cho triển khai liên tục (continuous deployment) bằng việc giữ lỗ hổng giữa development và production nhỏ</strong>. Nhìn vào ba lỗ hổng mô tả ở trên:</p>

<ul>
<li>Làm cho lỗ hổng thời gian nhỏ: một developer có thể viết code và để nó được triển khai trong vài giờ, thậm chí chỉ vài phút sau đó.</li>
<li>Làm cho chỗ hổng con người nhỏ: những developer người viết code liên quan chặt chẽ đến việc triển khai code và theo dõi hành vi của nó trong môi trường production.</li>
<li>Làm cho lỗ hổng các công cụ nhỏ: giữ môi trường development và production giống nhau nhất có thể.</li>
</ul>

<p>Tóm tắt những thứ trên vào một bảng như sau:</p>

<table>
<thead>
<tr>
<th></th>
<th>App truyền thống</th>
<th>Twelve-factor app</th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>Thời gian giữa các deploy</strong></td>
<td>Vài tuần</td>
<td>Vài giờ</td>
</tr>

<tr>
<td><strong>Người viết code và người triển khai code</strong></td>
<td>Người khác nhau</td>
<td>Cùng người</td>
</tr>

<tr>
<td><strong>Môi trường dev với production</strong></td>
<td>Khác nhau</td>
<td>Giống nhau nhất có thể</td>
</tr>
</tbody>
</table>

<p>Các backing service, ví dụ cơ sở dữ liệu của app, hệ thống hàng đợi, hoặc cache, là một nơi mà sự tương đồng của dev/prod là quan trọng. Nhiều ngôn ngữ đưa ra các thư viện giúp đơn giản hoá truy cập tới backing service, gồm <em>các bộ chuyển đổi (adapters)</em> đến các loại service khác nhau. Một số ví dụ trong bảng sau:</p>

<table>
<thead>
<tr>
<th>Loại</th>
<th>Ngôn ngữ</th>
<th>Thư viện</th>
<th>Adapters</th>
</tr>
</thead>

<tbody>
<tr>
<td>Database</td>
<td>Ruby/Rails</td>
<td>ActiveRecord</td>
<td>MySQL, PostgreSQL, SQLite</td>
</tr>

<tr>
<td>Queue</td>
<td>Python/Django</td>
<td>Celery</td>
<td>RabbitMQ, Beanstalkd, Redis</td>
</tr>

<tr>
<td>Cache</td>
<td>Ruby/Rails</td>
<td>ActiveSupport::Cache</td>
<td>Memory, filesystem, Memcached</td>
</tr>
</tbody>
</table>

<p>Lập trình viên thỉnh thoảng tìm kiếm kêu gọi tuyệt vời sử dụng một backing service nhỏ nhẹ (lightweight) trong môi trường local của họ, trong khi một backing service mạnh mẽ và nghiêm túc hơn sẽ sử dụng trong môi trường production. Ví dụ, sử dụng SQLite ở local và sử dụng PostgreSQL ở production; hoặc sử dụng bộ nhớ tiến trình ở local cho lưu đệm (caching) ở môi trường development và Memcached trong production.</p>

<p><strong>Twelve-factor developer thì tránh sử dụng các backing service khác nhau giữa development và production</strong>, thậm chí cả khi apdapters theo lý thuyết sẽ trừu tượng hoá bất kì sự khác nhau nào trong các backing service. Sự khác nhau giữa các backing service nghĩa là một phần nhỏ sự không tương thích sẽ làm việc và pass (vượt qua) các test (kiểm tra) trên development hoặc staging nhưng thất bại trên production. Các kiểu lỗi này tạo ra sự ma sát gây trở ngại trong triển khai liên tục. Giá của sự ma sát và sự cản trở đến sau này của triển khai liên tục là rất cao khi xem xét trong tích luỹ dần dần qua thời gian sống (lifetime) của app.</p>

<p>Những service local nhỏ nhẹ (lightweight) thì kém hấp dẫn so với trước đây. Các backing service hiện đại ví dụ Memcached, PostgreSQL, và RabbitMQ không khó để cài đặt và chạy nhờ các hệ thống đóng gói hiện tại, ví dụ Homebrew hay apt-get. Thêm nữa, các công cụ cung cấp khai báo (declarative) ví dụ Chef and Puppet đã kết hợp với những môi trường ảo nhỏ nhẹ ví dụ như Docker và Vagrant cho phép các developer chạy môi trường local gần đúng với môi trường production. Giá của việc cài đặt và sử dụng những hệ thống này là thấp hơn khi so với lợi ích về sự tương đồng dev/prod và triển khai liên tục.</p>

<p>Adapters cho các backing service khác nhau vẫn hữu ích, bởi vì chúng giúp chuyển sang các backing service mới tương đối không vất vả. Nhưng tất cả các deploy của app (môi trường của developer, staging, production) nên sử dụng các kiểu và phiên bản giống nhau của các backing service.</p>

<h1 id="11-logs-các-ghi-chép">11. Logs (Các ghi chép)</h1>

<p><em>Coi các log như dòng dữ liệu sự kiện</em></p>

<p><em>Các log</em> cung cấp khả năng quan sát đến hành vi của app đang chạy. Trong những môi trường trên nền máy chủ, chúng thông thường ghi và một tệp trên ổ đĩa (một logfile); nhưng đây chỉ là một định dạng đầu ra.</p>

<p>Các log là dòng dữ liệu của các sự kiện được tích tụ lại, theo tứ tự thời gian từ các dòng dữ liệu đầu ra của tất cả các process đang chạy và backing service. Các log trong định dạng thô của chúng điển hình là dạng text với mỗi sự kiện trên một dòng (mặc dù các backtrace (lần dấu ngược lại) của ngoại lệ có thể kéo dài ra nhiều dòng). Các log không có điểm đầu hay cuối cố định, nhưng lưu lượng liên tục giống như app đang vận hành.</p>

<p><strong>Một twelve-factor app không bao giờ bận tâm đến bản thân nó với sự định tuyến hoặc lưu trữ của dòng dữ liệu đầu ra (output stream) của nó.</strong> Nó không phải cố gắng ghi hay quản lý các logfile. Thay vì đó, mỗi process đang chạy ghi dòng dữ liệu sự kiện của nó, không bị cản trở, vào <code>stdout</code>. Trong quá trình phát triển, developer sẽ xem dòng dữ liệu ngay trên terminal (của sổ dòng lệnh) của họ để quan sát hành vì của app.</p>

<p>Trong các bản deploy staging hay production, mỗi dòng dữ liệu của process sẽ được bắt bởi môi trường thực thi, được đối chiếu với tất cả các dòng dữ liệu khác từ app, và được định tuyến tới một hoặc nhiều điểm đến cuối cùng để xem và lưu trữ lâu dài. Những điểm đến lưu trữ này thì không hiển thị hay có thể cấu hình bởi ứng dụng, thay vì đó hoàn toàn được quản lý bởi môi trường thực thi. Các định tuyến log mã nguồn mở (ví dụ Logplex và Fluentd) thì khả dụng cho mục đích này.</p>

<p>Dòng dữ liệu sự kiện cho một app có thể được định tuyến đến một tệp, hoặc được xem qua phần đuôi thời gian thực trong một terminal. Đáng kể nhất, dòng dữ liệu có thể được gửi đến một hệ thống lập chỉ mục sao chép (log indexing) và phân tích ví dụ như Splunk, hoặc một hệ thống lưu trữ dữ liệu với mục đích chung ví dụ Hadoop/Hive. Những hệ thống này cho phép sức mạnh và sự linh hoạt tuyệt vời để tìm hiểu hành vi của app qua thời gian, bao gồm:</p>

<ul>
<li>Tìm kiếm các sự kiện cụ thể trong quá khứ.</li>
<li>Đồ thị quy mô lớn của các xu hướng (ví dụ số request trên phút).</li>
<li>Kích hoạt cảnh báo theo phỏng đoán do người dùng định nghĩa (ví dụ như một cảnh báo khi số lượng lỗi trên phút vượt quá mức cho phép).</li>
</ul>

<h1 id="12-admin-processes">12. Admin processes</h1>

<p><em>Chạy các task admin/management (người quản trị/quản lý) như các process one-off (một lần)</em></p>

<p><a href="#8-concurrency-đồng-thời">Processes formation</a> là một loạt các process mà được sử dụng để thực hiện công việc thường lệ của app (ví dụ xử lý các yêu cầu web) khi nó chạy. Một cách riêng biệt, các developer sẽ thường thực hiện các task mang tính quản trị hoặc bảo trì cho ứng dụng, ví dụ:</p>

<ul>
<li>Chạy các di chuyển cơ sở dữ liệu (database migration) (ví dụ <code>manage.py migrate</code> trong Django, <code>rake db:migrate</code> trong Rails). Chạy một câu</li>
<li>Chạy một điều khiển (console) (hay cũng được biết như là một REPL shell) để chạy code tuỳ ý hoặc kiểm tra các mô hình ứng dụng dựa trên cơ sở dữ liệu trực tiếp. Hầu hết các ngôn ngữ cung cấp một REPL bằng việc chạy trình thông dịch mà không cần bất kỳ tham số nào (ví dụ <code>python</code> hay <code>perl</code>) hoặc trong một số trường hợp có một câu lệnh riêng biệt (ví dụ <code>irb</code> cho Ruby, <code>rails console</code> cho Rails).</li>
<li>Chạy những kịch bản (script) một lần (ví dụ <code>php scripts/fix_bad_records.php</code>).</li>
</ul>

<p>Các one-off admin process nên được chạy trong một môi trường giống nhau như là <a href="#6-processes-tiến-trình">các process chạy dài thường lệ</a> của app. Chúng chạy dựa trên một release, sử dụng chung codebase và config như bất kì process nào chạy dựa trên release đó. Admin code phải được chuyển kèm với code của ứng dụng để tránh các vấn đề về đồng bộ.</p>

<p>Các công nghệ dependency cô lập giống nhau nên được sử dụng trên tất cả các kiểu process. Ví dụ, nếu web viết bằng Ruby sử dụng câu lệnh <code>bundle exec</code> để khởi động, sau đó một database migration nên sử dụng <code>bundle exec rake db:migrate</code>. Tương tự như vậy, một chương trình Python sử dụng Virtualenv nên sử dụng phần cung cấp <code>bin/python</code> để chạy cả máy chủ web Tornado và bất kỳ các admin proccess <code>manage.py</code> nào.</p>

<p>Twelve-factor ủng hộ mạnh mẽ các ngôn ngữ mà cung cấp một REPL shell bên ngoài, và nó làm cho app dễ dàng chạy những script một lần. Trong một deply local, các developer gọi các admin process một lần bằng một câu lệnh shell trực tiếp bên trong thư mục làm việc của app. Trong một deploy production, các developer có thể sử dụng <code>ssh</code> hoặc cơ chế thực thi câu lệnh từ xa khác được cung cấp bởi môi trường thực thi của deploy để chạy ví dụ một process.</p>

<p>Dịch bởi: <code>code2080</code></p>

        </div>

        
        
        <div class="article-toc" >
            <nav id="TableOfContents">
<ul>
<li><a href="#mở-đầu">MỞ ĐẦU</a>
<ul>
<li><a href="#giới-thiệu">Giới thiệu</a></li>
<li><a href="#khởi-nguồn">Khởi nguồn</a></li>
<li><a href="#ai-nên-đọc-tài-liệu-này">Ai nên đọc tài liệu này?</a></li>
</ul></li>
<li><a href="#1-codebase-toàn-bộ-mã-nguồn-dự-án">1. Codebase (Toàn bộ mã nguồn dự án)</a></li>
<li><a href="#2-dependencies-các-phụ-thuộc">2. Dependencies (Các phụ thuộc)</a></li>
<li><a href="#3-config-cấu-hình">3. Config (Cấu hình)</a></li>
<li><a href="#4-backing-services-dịch-vụ-phía-sau">4. Backing services (Dịch vụ phía sau)</a></li>
<li><a href="#5-build-release-phát-hành-run">5. Build, release (phát hành), run</a></li>
<li><a href="#6-processes-tiến-trình">6. Processes (Tiến trình)</a></li>
<li><a href="#7-port-binding">7. Port binding</a></li>
<li><a href="#8-concurrency-đồng-thời">8. Concurrency (Đồng thời)</a></li>
<li><a href="#9-disposability-khả-năng-sẵn-sàng">9. Disposability (Khả năng sẵn sàng)</a></li>
<li><a href="#10-dev-prod-parity-tương-đồng-giữa-phát-triển-và-sản-phẩm">10. Dev/prod parity (Tương đồng giữa phát triển và sản phẩm)</a></li>
<li><a href="#11-logs-các-ghi-chép">11. Logs (Các ghi chép)</a></li>
<li><a href="#12-admin-processes">12. Admin processes</a></li>
</ul>
</nav>
        </div>
        
        

        


        
        <footer class="article-footer">
            <ul class="article-tag-list">
                
                <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="https://code2080.com/tags/software-development">software development
                    </a>
                </li>
                
                <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="https://code2080.com/tags/translation">translation
                    </a>
                </li>
                
            </ul>
        </footer>
        
    </div>
    <nav id="article-nav">
    
    
    <a href="/about/" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title">About me&nbsp;<span>&gt;</span></div>
    </a>
    
</nav>
</article>

        
    </section>
    <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 Code Twenty Eighty.
            Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/carsonip/hugo-theme-minos">Minos</a>.
        </div>
    </div>
    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css" integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin="anonymous"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>
</div>
</body>
</html>
